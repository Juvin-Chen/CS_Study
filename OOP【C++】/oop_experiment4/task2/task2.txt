问题1：继承关系识别
写出 GradeCalc 类声明体现"继承"关系的完整代码行。
class GradeCalc:private std::vector<int>

问题2：接口暴露理解
当前继承方式下，基类 vector<int> 的接口会自动成为 GradeCalc 的接口吗？
如在 test 模块中这样用，能否编译通过？用一句话解释原因。
GradeCalc c("OOP");
c.input(5);
c.push_back(97); // 合法吗？
不会自动成为GradeCalc的接口
std::vector的公共接口在GradeCalc中都变成了private，外部无法直接调用c.push_back()。

问题3：数据访问差异
对比继承方式与组合方式内部实现数据访问的一行典型代码。说明两种方式下的封装差异带来的数据访问接口差异。
继承是把对象当作容器本身用，访问数据时通常是直接用*this指针
组合方式明确有一个成员grades，访问直接通过grades调用vector容器当中的接口

问题4：组合 vs. 继承方案选择
你认为组合方案和继承方案，哪个更适合成绩计算这个问题场景？简洁陈述你的结论和理由。
肯定是组合，继承是is-a，这里的成绩计算器明显更适合has-a，借助它来存放成绩。