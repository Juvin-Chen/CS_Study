# 栈的应用

## 一、数制转换

数制转换的原理为：$N = (N \text{ div } d) \times d + N \text{ mod } d$

计算顺序和输出顺序相反，故适合使用栈。

### 算法步骤

> **示例**：输入十进制数，输出其对应的八进制数

1. 初始化一个空栈 `S`。
2. 当十进制数 `N` 非零时，循环执行以下操作：
   - 把 `N` 与 8 求余得到的八进制数压入栈 `S`；
   - `N` 更新为 `N` 与 8 的商。
3. 当栈 `S` 非空时，循环执行以下操作：
   - 弹出栈顶元素 `e`；
   - 输出 `e`。

```cpp
void conversion(){
    InitStack(S);
    scanf("%d", &N);
    while(N){
        Push(S, N % 8);
        N = N / 8;
    }
    while(!StackEmpty(S)){
        Pop(S, e);
        printf("%d", e);
    }
}
```

- **基本操作**：除法
- **时间复杂度**：$O(\log_2 N)$
- **空间复杂度**：$O(\log_2 N)$

## 二、简单表达式括号匹配

**简单表达式**：整数、四则运算符、圆括号、中括号、花括号。

检验简单表达式中的括号是否合乎规则：

- **正确**：`（［］（））` 或 `［（［ ］［ ］）］`
- **错误**：`［（］）` 或 `（［（）] ` 或 `[ ( ) ] )`

**原理**：

- 后出现的左括号，期待匹配的程度较先出现的高。
- 当出现一个右括号，只能和**最近**的左括号匹配。
- 可见，括弧匹配也遵循“后进先出”的规律。

### 算法思想

1. 非括号符号不予处理；
2. 凡出现**左括弧**，则进栈；
3. 凡出现**右括弧**，首先检查栈是否空？
   - 若栈空，则表明该“右括弧”多余；
   - 若不空，和栈顶元素比较：
     - 若相匹配，则“左括弧出栈”；
     - 否则表明不匹配。
4. 表达式检验结束时：
   - 若栈空，则表明表达式中匹配正确；
   - 否则表明“左括弧”有余。

> **示例**：检测长度为 n 的字符序列 exp 中的括弧是否匹配

C

```
bool matching(char exp[], int n){
    int i = 0; 
    bool mat = true; 
    InitStack(S);
    while(i < n && mat){
        switch (exp[i]) {
            case '(': 
                Push(S, exp[i]); 
                i++; 
                break;
            case ')':
                if( !StackEmpty(S) && GetTop(S) == '(' ){
                    Pop(S, e); 
                    i++; 
                } else { 
                    mat = false; 
                }
                break;
            case '[':
                // ... ...
                break;
        }
    }
    return mat;
}
```

## 三、简单表达式求值

计算包含加减乘除正整数和圆括号的合法算术表达式，计算表达式的运算结果。

中缀表达式：

运算符位于两个操作数中间的表达式称为中缀表达式。例如，1+2*3 就是一个中缀表达式。

### 1. 中缀表达式-双栈直接计算法

设定两栈：

- `OPND`：操作数栈，存放操作数及中间运算结果；
- `OPTR`：操作符栈，存放运算符。

#### 算法步骤

1. 初始化 `OPTR` 栈和 `OPND` 栈，将表达式起始符 `#` 压入 `OPTR` 栈。
2. 扫描表达式，读入字符 `ch`；如果表达式没有扫描完毕至 `#` 或 `OPTR` 的栈顶元素不为 `#` 时，则循环执行以下操作：
   - 若 `ch` **不是运算符**，则压入 `OPND` 栈，读入下一字符 `ch`；
   - 若 `ch` **是运算符**，则根据 `OPTR` 的栈顶元素和 `ch` 的优先级比较结果，做不同的处理：
     - **小于 (<)**：则 `ch` 压入 `OPTR` 栈，读入下一字符 `ch`；
     - **大于 (>)**：则弹出 `OPTR` 栈顶的运算符，从 `OPND` 栈弹出两个数，进行相应运算，结果压入 `OPND` 栈；
     - **等于 (=)**：并且 `OPTR` 的栈顶元素是 `(`，且 `ch` 是 `)`，这时弹出 `OPTR` 栈顶的 `(`，相当于括号匹配成功，然后读入下一字符 `ch`。

C++

```
OperandType EvaluateExpression(){
    InitStack(OPTR); Push(OPTR, '#');
    InitStack(OPND); ch = getchar();
    
    while(ch != '#' || GetTop(OPTR) != '#'){
        if (!In(ch)) { 
            Push(OPND, ch); 
            cin >> ch; // ch不是运算符则进栈
        } else {
            switch (Precede(GetTop(OPTR), ch)) { // 比较优先权
                case '<': // 当前字符 ch 压入 OPTR 栈，读入下一字符 ch
                    Push(OPTR, ch); 
                    cin >> ch; 
                    break;
                case '>': // 弹出 OPTR 栈顶的运算符运算，并将运算结果入栈
                    Pop(OPTR, theta);
                    Pop(OPND, b); 
                    Pop(OPND, a);
                    Push(OPND, Operate(a, theta, b)); 
                    break;
                case '=': // 脱括号并接收下一字符
                    Pop(OPTR, x); 
                    cin >> ch; 
                    break;
            } // switch
        }
    } // while
    return GetTop(OPND);
}
```

- **时间复杂度**：$O(n)$

### 2. 中缀转后缀-后缀求值法

#### 后缀表达式

算术表达式的另一种形式是后缀表达式（逆波兰表达式），就是在算术表达式中，运算符在操作数的后面。

如 1+2*3 的后缀表达式为 1 2 3 * +。

- 已考虑了运算符的优先级。
- 没有括号。
- 只有操作数和运算符，而且越放在前面的运算符越优先执行。

#### 后缀表达式的计算

先找运算符，再找操作数。

例如：a b * c d e / - f * +

#### 后缀表达式求值算法思想

1. 建立一个栈 `S`；
2. 从左到右扫描后缀表达式；
   - 遇到**数字**就将其转换为数值压入栈 `S` 中；
   - 遇到**运算符** `op`，则从栈中依次弹出两个数 `Y` 和 `X`，然后以 `X op Y` 的形式计算。将计算结果压入栈 `S` 中；
3. 重复执行，直到表达式扫描完毕，最后输出栈顶的数值即为表达式的结果；

> **结论**：如果把输入的表达式转换成后缀式，则计算机能够非常简单地运算得到结果。

#### 中缀转后缀算法思想

设立暂存运算符的栈；设表达式的结束符为 `#`， 预设运算符栈的栈底为 `#`。

依次读入中缀表达式的字符：

1. 若当前字符是**操作数**，则直接发送给后缀式；
2. 若当前字符是**运算符**：
   - 若是 `(` ：则直接进栈；（指定 `(` 的优先级低于所有运算符）
   - 若是 `)` ：则出栈至第一个 `(`，将出栈符号发送给后缀式；
   - 若运算符的优先级 **高于** 栈顶运算符，则进栈；
   - 否则，出栈栈顶运算符发送给后缀式。

> （其实简单讲就是：运算符栈里面优先级大的操作符必须要在上面）

### 3. 表达式树法

> 借助二叉树
>
> 略....